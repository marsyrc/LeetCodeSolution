                        分治 	     动态规划 	    贪心

适用类型 	    通用 	            优化 	            优化
子问题 	        每个都不同 	有很多重复 	只有一个
最优子结构 	没有要求 	    必须满足 	    必须满足
子问题数 	    全部都要解 	全部都要解 	只解一个

# 线性动态规划



## 单串

单串 dp[i] 线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 dp[i] := 考虑[0..i]上，原问题的解，其中 i 位置的处理，根据不同的问题，主要有两种方式：

    第一种是 i 位置必须取，此时状态可以进一步描述为 dp[i] := 考虑[0..i]上，且取 i，原问题的解；
    第二种是 i 位置可以取可以不取



### 1. 单串问题：LIS系列

- 最长上升子序列

  方程设置以当前位置为结尾的最长递增子序列长度

  n ^ 2复杂度

- 最长递增子序列的个数

  设置一个count数组记录当前元素结尾的LIS数量，和LIS一样，如果`dp[i]`被`dp[j] + 1`更新了,count也要被j处的count更新。

  ```go
  for j := 0; j < i; j++ {
  	if nums[j] < nums[i] {
  		if dp[j]+1 > dp[i] {
  			dp[i] = dp[j] + 1
  			count[i] = count[j]
  		} else if dp[i] == dp[j]+1 {
  				count[i] += count[j]
  		}
  }
  ```

  

- 俄罗斯套娃信封问题 —— LIS

  ```go
  func maxEnvelopes(envelopes [][]int) int {
      sort.Slice(envelopes, func(i, j int) bool {
          return envelopes[i][0] < envelopes[j][0] || (envelopes[i][0] == envelopes[j][0] && envelopes[i][1] > envelopes[j][1])
      })
      n := len(envelopes)
      if n == 0 {
          return 0
      }
  
      res := 1
      dp := make([]int, n)
      dp[0] = 1
      for i := 1; i < n; i++ {
          dp[i] = 1
          for j := 0; j < i; j++ {
              if envelopes[i][1] > envelopes[j][1] {
                  dp[i] = max(dp[i], dp[j] + 1)
              } 
          }
          res = max(res, dp[i])
      } 
      return res
  }
  
  func max(a, b int) int {
      if a > b {
          return a
      }
      return b
  }
  ```

  两维都要严格递增，所以用排序固定一维，对另一维求最长递增子序列

### 2. 单串问题：最大子数组和

从动态规划角度讲，最大子数组和是以一类较简单的 DP 问题，但它的状态设计比较经典，同时也是很多问题的基础组件，需要专门掌握。

- 最大子序和

  正的加入，负的丢弃

- 乘积最大子数组

  维护每个索引处的最大值和最小值

- 环形子数组的最大和 —— 环形数组的处理

  1. 考虑正常的数组内最大子数组和
  2. 两端的情况下，可以用`sum - dpmin(1, len(nums) - 2)`

- 最大子矩阵 —— 思路类似一维的最大子数组和

  遍历左右边界，求出当前边界下`rowSum`，压缩成一维，求最大子数组和

- 矩形区域不超过 K 的最大数值和 —— 在上一题基础上加了一个 K

### 3. 打家劫舍主要是不相邻子序列的最大和问题，以及若干变形

- 打家劫舍

  ```go
  dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
  ```

- 打家劫舍 II

  ```go
  //首尾不能相连
  a1 := a[1:]
  a2 := a[:len(a) - 1]
  res = max(f(a1), f(a2))
  ```

- 删除与获得点数

  

- 3n 块披萨

### 4.单串问题：变形，需要两个位置的情况: dp[i][j] 以 j, i 结尾、
有一些单串问题在涉及状态时需要考虑最后两位的情况，因为只考虑最后一个的话无法对状态描述清楚，例如下面两道题。

- 最长的斐波那契子序列的长度 —— dp[i][j]:= 以 j, i 结尾，转移时在 [0..j] 中找满足条件的 k 这一步可以二分或哈希表
- 最长等差数列 —— dp[i][j]:= 以 j, i 结尾，转移时在 [0..j] 中找满足条件的 k 这一步用哈希表，键为数组值，值为保存下标的平衡树

### 5.单串问题：与其它算法配合

线性动态规划经常要与其它算法和数据结构配合来解决问题，例如二分，贪心，排序的等。

- 形成字符串的最短路径 —— DP + 二分，贪心
- 最大整除子集 —— 先对数组排序



## 带维度的单串问题

串的问题，子问题仅与位置 i 有关时，就形成单串 dp[i] 的问题。在此基础上，如果子问题还与某种指标 k 有关，k 的物理意义比较常见的有长度，个数，次数，颜色等，则是另一大类问题，状态通常写成 dp[i] [k]。其中 k 上可能有二分，贪心等算法.

当 i 变小时，形成小规模子问题，当 k 变小时，也形成小规模子问题，因此推导 dp[i] [k]时，i 和 k 两个维度分别是一个独立的单串 dp[i] 问题。推导 k 时，k 可能与 k - 1,...,1 中的所有小规模问题有关，也可能只与其中常数个有关，参考单串 dp[i] 问题中的两种情况。

在单串问题中，可能仅用一个维度表示当前子问题是考虑到串上的哪个位置是不够的，需要增加维度，通常用 k 表示，k 随着题目的不同，可以表示长度，个数，次数，颜色等，同时 k 这个维度的枚举和转移可能涉及到二分，贪心等算法。这是线性而动态规划比较难的部分。

    最大平均值和的分组 —— k 是个数 (这题不错的呢)
    鸡蛋掉落 —— k 是次数，k 上有二分
    粉刷房子 —— k 是颜色
    粉刷房子 II —— k 是颜色
    奇偶跳 —— k 表示当前的奇偶状态
    青蛙过河 —— k 表示上一步的跳的步数
    安排邮筒 —— k 是个数，前缀和维护状态转移时的查询
    抛掷硬币 —— k 是个数
    分割数组的最大值 —— k 是份数
    给房子涂色 III —— 有两个指标 k 颜色；t 街区数



## 股票问题

股票系列问题是 dp[i] [k] 这种状态设计模式的经典问题。

    买卖股票的最佳时机
    买卖股票的最佳时机 II
    买卖股票的最佳时机 III
    买卖股票的最佳时机 IV
    最佳买卖股票时机含冷冻期
    买卖股票的最佳时机含手续费



## 双串

有两个输入从串，长度分别为 m, n，此时子问题需要用 i, j 两个变量表示，分别代表第一个串和第二个串考虑的位置 dp[i] [j]:=第一串考虑[0..i]，第二串考虑[0..j]时，原问题的解

较大规模的子问题只与常数个较小规模的子问题有关，其中较小规模可能是 i 更小，或者是 j 更小，也可以是 i，j 同时变小。
其中一种最常见的状态转移形式：推导 dp[i] [j] 时，dp[i] [j] 仅与 dp[i-1] [j], dp[i] [j-1], dp[i-1] [j-1]，例如

    72 编辑距离
    712 两个字符串的最小 ASCII 删除和



### 1. 双串问题：最经典双串 LCS 系列

最长公共子序列是双串的最经典的问题，很多双串问题的状态设计都是启发自这到底。

    最长公共子序列 1143.go
    两个字符串的最小 ASCII 删除和 —— LCS，len 和 ascii 各一个 dp
    最长重复子数组 —— 最长公共子串，注意与最长公共子序列的区别 718
    
    718和1143的区别是 最长公共子序列不需要连续， 当前两个匹配不上则dp[i][j] = 两个元素中任意一个的前一个状态的最大值
    而最长重复子数组中，匹配不上就是0



### 2. 双串问题：字符串匹配系列

双串的问题一般是给定两个字符串，或者两个数组。这种情况的状态设计一般都会首先考虑如下的状态设计，这也是最长公共子序列问题启发我们的。

dp[i] [j] := 第一串考虑到 i, 第二串考虑得到 j ，原问题的解。

有了这种状态设计方法，我们立刻就可以解决一些初看比较难的字符串的模糊匹配的问题

    编辑距离
    通配符匹配
    正则表达式匹配



### 3.双串问题：其它双串 dp[i] [j] 问题

以下两道题较难，但仍然用到了前面的状态设计方法。


- 交错字符串
- 不同的子序列



### 4. 双串问题：带维度双串 dp[i] [j] [k]

在双串的场景下，依然可能会有额外的维度需要插入，例如下面这一题


- 扰乱字符串



## 矩阵

### 1. 矩阵问题dp[i] [j]

除了数组和字符串外，矩阵也是一种线性结构，很多一维数组或字符串的问题可以推广到二维，因此矩阵上也有一些经典的动态规划问题，矩阵上的动态规划问题，基本的状态设计就是用两维变量 (i, j) 共同表示以 (0, 0) 为左上角，(i, j) 为右下角的子问题。

    三角形最小路径和
    最小路径和
    地下城游戏
    下降路径最小和
    最大正方形
    下降路径最小和 II



### 2. 矩阵问题 dp[i] [j] [k]

与一维的情况一样，矩阵上也有问题仅仅用 (i, j) 表示子问题边界点的位置是不够的，需要增加维度 k，其中随着题目不同 k 可能是次数，长度等指标

    最大矩形
    矩形区域不超过 K 的最大数值和 —— k 为宽度
    最大子矩阵 —— 思路类似一维的最大子数组和
    切披萨的方案数 —— 需要二维前缀和判断两个状态之间能否转移



## 无串线性问题

线性动态规划有一类问题是没有显式的数组或字符串的。但在计算中依然可以分成若干子问题，且有动态规划的三条性质。因此也可以用动态规划来解。

    只有两个键的键盘
    丑数 II
    完全平方数
    整数拆分



## 总结

线性动态规划是动态规划中最基础的一类，它的状态一般物理意义很明确，易于分析。在初学动态规划时，通过线性动态规划的大量练习，可以不断加深动态规划的概念理解，例如动态规划中最重要的三个概念：最有子结构，重复子问题，无后效性。下面对动态规划的三个基本概念做个简要回顾，在线性动态规划的题目练习中可以不断地加深理解，之后再学习其它的动态规划类型就会容易很多。

    最优子结构：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构。
    无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
    重复子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

线性动态规划是动态规划中变化最多的一类。

首先线性动态规划针对的问题是最常见的数组，字符串，矩阵等，这三种数据结构本身就是线性的，因此出现这些类型的输入的时候，如果要用到动态规划，首先考虑线性动态规划就很合理了，因此很多问题不论最后正解是不是线性动态规划，都会首先想一下线性动态规划是否可行。

其次由于大部分问题的数据都是以这三种形式给出的，因此题目的变化会非常多，很多常见的输入形式以及问题都非常经典，都存在经典的状态设计。因此不考虑一些比较 Trick 的解法，仅仅是经典问题的经典状态设计，就比其它种类的动态规划问题多很多了。

例如单个数组或字符串上设计一维状态，两个数组或字符串上设计两维状态，以及矩阵上设计两维状态等等，同时以上三种情况的状态设计都有可能再加上额外的指标的状态，就是前面例题中的 k，这里面变化就很多了，比如有的题目在 k 这一维上要使用二分，贪心的策略，有的题目需要 DP 状态与数据结构配合来解决问题。

除此之外还有一类问题没有显式的数组，字符串，但是在求解的时候依然满足前面提到的动态规划三条基本概念，可以用动态规划求解，这种问题通常也是线性动态规划。如此多的变化仅仅本小节例举的题目是远远不够的，下一小节是线性动态规划的练习题，涉及到对线性动态规划的更多的变化。

