# 求区间和

利用前缀和求区间和的思想，已经求前缀和的过程在上一节中已经重点介绍，这里主要回顾一下前缀和中的动态规划思想，如下：

```
状态定义：sums[i] := [0..i-1] 的和
状态转移：sums[i] = a[i - 1] + sums[i - 1]
初始化：sums[0] = 0
```

这是最简单的单串线性动态规划，其思想在上一章重点介绍。求解该动态规划问题后得到数组 sums 。然后区间和问题就变成了两个前缀和的差的问题。

```
int rangeRum(int L, int R)
{
    return sums[R + 1] - sums[L];
}
```

**一维情况 leetcode 303**

**二维情况 leetcode 304**



# 数据结构维护前缀和

在上一节中提到，在用 dp 的方式推 sums[i] 的时候，有时求完 sums[i] 需要查询以前算过的结果计算某种指标，需要用其它数据结构将前面的计算结果维护起来，以便高效查询。以下几个问题就是以上思路的直接应用。

将前缀和维护在数据结构中，以便于后续的 多次 查询，最常见的是维护在哈希表中。

力扣上这种题目非常多，更多题目详见本章后续节。下面考虑几个经典问题：

    第一问：a0,a1,...,an−1 上有没有一个区间，其和为 target 。

计算前缀和数组 sums[i] 。当扫描到 i 时， a0,a1,...,ai−1 的前缀和都已经求过了，在计算的过程中将前缀和维护在数据结构中，以便于后续的多次查询，本题在之后要查询前缀和的值是否存在，因此维护在unordered_set(哈希表)里。

求完当前值 a[i] 对应的前缀和 S[i+1], 在插入到 unordered_set 之前先问：S[i+1] - target 在 unordered_set 中是否出现。

    如果出现，说明存在以 i 结尾的某个区间，和为 target, 则找到答案。
    如果不出现，则没有以 i 结尾的区间，和为 target，继续枚举 i+1。

上面的问题还可以有变种：

    第二问：a0,a1,...,an−1 上有多少个区间，其和为 target 。

按照第一问的思路，把 unordered_set 改成 unordered_map 就可以

参考题目：**560. 和为 K 的子数组**

    第三问：a0,a1,...,an−1 上有没有一个区间，其和大于/小于 target 。

整体思路与第一问相同，但是维护前缀和的数据结构需要从哈希表变为线段树（**使用了归并的方法解决**）

参考题目：**327. 区间和的个数**

    第四问: 一棵树上有没有某个路径，其和为 target

这是第一问的树形版本，dfs（前序遍历）时，栈里存的是当前节点到根的链，这条链上的和可以作为前缀和维护在 unordered_map 里。从左子树跳到右子树的时候，左子树的所有节点对应的前缀和要先从 unordered_map 中删掉。

参考题目： **437. 路径总和 III**

数据结构维护前缀和相关练习题：

    HashMap 维护 (1)，键是前缀和（状态）的值，值为第一次出现时的索引
    HashMap 维护 (2)，键是前缀和（前缀状态）的值，值为出现次数
    HashMap 维护 (3)，键是前缀和模 K 的余数（可以理解为前缀状态，状态为前缀和模K）
    前缀和（积）与后缀和（积）均需要
    二维前缀和






