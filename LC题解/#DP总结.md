# 线性动态规划



## 单串

单串 dp[i] 线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 dp[i] := 考虑[0..i]上，原问题的解，其中 i 位置的处理，根据不同的问题，主要有两种方式：

    第一种是 i 位置必须取，此时状态可以进一步描述为 dp[i] := 考虑[0..i]上，且取 i，原问题的解；
    第二种是 i 位置可以取可以不取



### 1. 单串问题：LIS系列

- 最长上升子序列
- 最长递增子序列的个数
- 俄罗斯套娃信封问题 —— LIS

### 2. 单串问题：最大子数组和

从动态规划角度讲，最大子数组和是以一类较简单的 DP 问题，但它的状态设计比较经典，同时也是很多问题的基础组件，需要专门掌握。

- 最大子序和
- 乘积最大子数组
- 环形子数组的最大和 —— 环形数组的处理
- 最大子矩阵 —— 思路类似一维的最大子数组和
- 矩形区域不超过 K 的最大数值和 —— 在上一题基础上加了一个 K

### 3. 打家劫舍主要是不相邻子序列的最大和问题，以及若干变形

- 打家劫舍
- 打家劫舍 II
- 删除与获得点数
- 3n 块披萨

### 4.单串问题：变形，需要两个位置的情况: dp[i][j] 以 j, i 结尾、
有一些单串问题在涉及状态时需要考虑最后两位的情况，因为只考虑最后一个的话无法对状态描述清楚，例如下面两道题。

- 最长的斐波那契子序列的长度 —— dp[i][j]:= 以 j, i 结尾，转移时在 [0..j] 中找满足条件的 k 这一步可以二分或哈希表
- 最长等差数列 —— dp[i][j]:= 以 j, i 结尾，转移时在 [0..j] 中找满足条件的 k 这一步用哈希表，键为数组值，值为保存下标的平衡树

### 5.单串问题：与其它算法配合

线性动态规划经常要与其它算法和数据结构配合来解决问题，例如二分，贪心，排序的等。

- 形成字符串的最短路径 —— DP + 二分，贪心
- 最大整除子集 —— 先对数组排序



## 带维度的单串问题

串的问题，子问题仅与位置 i 有关时，就形成单串 dp[i] 的问题。在此基础上，如果子问题还与某种指标 k 有关，k 的物理意义比较常见的有长度，个数，次数，颜色等，则是另一大类问题，状态通常写成 dp[i] [k]。其中 k 上可能有二分，贪心等算法.

当 i 变小时，形成小规模子问题，当 k 变小时，也形成小规模子问题，因此推导 dp[i] [k]时，i 和 k 两个维度分别是一个独立的单串 dp[i] 问题。推导 k 时，k 可能与 k - 1,...,1 中的所有小规模问题有关，也可能只与其中常数个有关，参考单串 dp[i] 问题中的两种情况。

在单串问题中，可能仅用一个维度表示当前子问题是考虑到串上的哪个位置是不够的，需要增加维度，通常用 k 表示，k 随着题目的不同，可以表示长度，个数，次数，颜色等，同时 k 这个维度的枚举和转移可能涉及到二分，贪心等算法。这是线性而动态规划比较难的部分。

    最大平均值和的分组 —— k 是个数
    鸡蛋掉落 —— k 是次数，k 上有二分
    粉刷房子 —— k 是颜色
    粉刷房子 II —— k 是颜色
    奇偶跳 —— k 表示当前的奇偶状态
    青蛙过河 —— k 表示上一步的跳的步数
    安排邮筒 —— k 是个数，前缀和维护状态转移时的查询
    抛掷硬币 —— k 是个数
    分割数组的最大值 —— k 是份数
    给房子涂色 III —— 有两个指标 k 颜色；t 街区数





## 股票问题

股票系列问题是 dp[i] [k] 这种状态设计模式的经典问题。

    买卖股票的最佳时机
    买卖股票的最佳时机 II
    买卖股票的最佳时机 III
    买卖股票的最佳时机 IV
    最佳买卖股票时机含冷冻期
    买卖股票的最佳时机含手续费



## 双串

有两个输入从串，长度分别为 m, n，此时子问题需要用 i, j 两个变量表示，分别代表第一个串和第二个串考虑的位置 dp[i] [j]:=第一串考虑[0..i]，第二串考虑[0..j]时，原问题的解

较大规模的子问题只与常数个较小规模的子问题有关，其中较小规模可能是 i 更小，或者是 j 更小，也可以是 i，j 同时变小。
其中一种最常见的状态转移形式：推导 dp[i] [j] 时，dp[i] [j] 仅与 dp[i-1] [j], dp[i] [j-1], dp[i-1] [j-1]，例如

    72 编辑距离
    712 两个字符串的最小 ASCII 删除和



### 1. 双串问题：最经典双串 LCS 系列

最长公共子序列是双串的最经典的问题，很多双串问题的状态设计都是启发自这到底。

    最长公共子序列
    两个字符串的最小 ASCII 删除和 —— LCS，len 和 ascii 各一个 dp
    最长重复子数组 —— 最长公共子串，注意与最长公共子序列的区别



### 2. 双串问题：字符串匹配系列

双串的问题一般是给定两个字符串，或者两个数组。这种情况的状态设计一般都会首先考虑如下的状态设计，这也是最长公共子序列问题启发我们的。

dp[i][j] := 第一串考虑到 i, 第二船考虑得到 j ，原问题的解。

有了这种状态设计方法，我们立刻就可以解决一些初看比较难的字符串的模糊匹配的问题

    编辑距离
    通配符匹配
    正则表达式匹配



### 3.双串问题：其它双串 dp[i] [j] 问题

以下两道题较难，但仍然用到了前面的状态设计方法。
 

- 交错字符串
- 不同的子序列



### 4. 双串问题：带维度双串 dp[i] [j] [k]

在双串的场景下，依然可能会有额外的维度需要插入，例如下面这一题
 

- 扰乱字符串